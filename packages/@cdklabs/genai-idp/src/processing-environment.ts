/*
Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

import { IInvokable } from "@cdklabs/generative-ai-cdk-constructs/lib/cdk-lib/bedrock";
import * as cdk from "aws-cdk-lib";
import * as cloudwatch from "aws-cdk-lib/aws-cloudwatch";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as events from "aws-cdk-lib/aws-events";
import * as eventtargets from "aws-cdk-lib/aws-events-targets";
import * as kms from "aws-cdk-lib/aws-kms";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambda_event_sources from "aws-cdk-lib/aws-lambda-event-sources";
import * as logs from "aws-cdk-lib/aws-logs";
import { IBucket } from "aws-cdk-lib/aws-s3";
import * as sqs from "aws-cdk-lib/aws-sqs";

import { Construct } from "constructs";
import { ConcurrencyTable, IConcurrencyTable } from "./concurrency-table";
import { ConfigurationTable, IConfigurationTable } from "./configuration-table";
import { IDocumentDiscovery } from "./document-discovery";
import { IDocumentProcessor } from "./document-processor";
import * as functions from "./internal/functions";
import { LogLevel } from "./log-level";
import { IProcessingEnvironmentApi } from "./processing-environment-api";
import { IReportingEnvironment } from "./reporting";
import { ITrackingTable, TrackingTable } from "./tracking-table";
import { VpcConfiguration } from "./vpc-configuration";

export interface DocumentProcessorAttachmentOptions {
  readonly prefix?: string;
  readonly evaluationBucket?: IBucket;
  readonly evaluationModel?: IInvokable;
}

export interface IProcessingEnvironment {
  /**
   * Optional KMS key used for encrypting sensitive data in the processing environment.
   * When provided, ensures that document content and metadata are encrypted at rest.
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * The S3 bucket where source documents to be processed are stored.
   * This bucket is monitored for new document uploads to trigger processing.
   */
  readonly inputBucket: IBucket;

  /**
   * The S3 bucket where processed documents and extraction results are stored.
   * Contains the structured data output and processing artifacts.
   */
  readonly outputBucket: IBucket;

  /**
   * The S3 bucket used for temporary storage during document processing.
   * Contains intermediate processing artifacts and working files.
   */
  readonly workingBucket: IBucket;

  /**
   * The DynamoDB table that stores configuration settings.
   * Contains document schemas, extraction parameters, and other system-wide settings.
   */
  readonly configurationTable: IConfigurationTable;

  /**
   * The Lambda function that updates configuration settings.
   * Used to initialize and update configuration during deployment and runtime.
   */
  readonly configurationFunction: lambda.IFunction;

  /**
   * The namespace for CloudWatch metrics emitted by the document processing system.
   * Used to organize and identify metrics related to document processing.
   */
  readonly metricNamespace: string;

  /**
   * The log level for document processing components.
   * Controls the verbosity of logs generated during document processing.
   */
  readonly logLevel: LogLevel;

  /**
   * The retention period for CloudWatch logs generated by document processing components.
   * Controls how long system logs are kept for troubleshooting and auditing.
   */
  readonly logRetention?: logs.RetentionDays;

  /**
   * The DynamoDB table that tracks document processing status and metadata.
   * Stores information about documents being processed, including status and results.
   */
  readonly trackingTable: ITrackingTable;

  /**
   * Optional VPC configuration for document processing components.
   * When provided, deploys processing components within a VPC with specified settings.
   */
  readonly vpcConfiguration?: VpcConfiguration;

  /**
   * Optional reporting environment for analytics and evaluation capabilities.
   * When provided, enables storage and querying of evaluation metrics and processing analytics.
   */
  readonly reportingEnvironment?: IReportingEnvironment;

  /**
   * Optional Lambda function that saves reporting data to the reporting bucket.
   * Available when a reporting environment is provided.
   */
  readonly saveReportingDataFunction?: lambda.IFunction;

  /**
   * Optional ProcessingEnvironmentApi for progress notifications.
   * When provided, functions will use GraphQL mutations to update document status
   * and notify clients about processing progress.
   */
  readonly api?: IProcessingEnvironmentApi;

  /**
   * Optional document discovery system for automated configuration generation.
   * When provided, enables discovery job processing, status tracking, and UI upload functionality.
   */
  readonly documentDiscovery?: IDocumentDiscovery;

  /**
   * Attaches a document processor to this processing environment.
   * Sets up the necessary event triggers, permissions, and integrations
   * to enable the processor to work with this environment.
   *
   * @param processor The document processor to attach to this environment
   */
  attach(
    processor: IDocumentProcessor,
    options?: DocumentProcessorAttachmentOptions,
  ): void;
}
/**
 * Configuration properties for the Intelligent Document Processing environment.
 * This construct orchestrates the end-to-end document processing workflow,
 * from document ingestion to structured data extraction and result tracking.
 *
 * The processing environment provides the shared infrastructure and services
 * that all document processor patterns use, including storage, tracking,
 * API access, and monitoring capabilities.
 */
export interface ProcessingEnvironmentProps {
  /**
   * The KMS key used for encrypting resources in the document processing workflow.
   * Provides encryption for queues, logs, and other sensitive components.
   */
  readonly key?: kms.IKey;

  /**
   * The S3 location where source documents to be processed are stored.
   * This bucket will be monitored for new document uploads to trigger processing.
   */
  readonly inputBucket: IBucket;

  /**
   * The S3 location where processed documents and extraction results will be stored.
   * Contains the structured data output and processing artifacts.
   */
  readonly outputBucket: IBucket;

  /**
   * The S3 bucket used for temporary storage during document processing.
   * Contains intermediate processing artifacts and working files.
   */
  readonly workingBucket: IBucket;

  /**
   * Optional DynamoDB table for storing configuration settings.
   * When not provided, a new table will be created.
   * Contains document schemas, extraction parameters, and other system-wide settings.
   */
  readonly configurationTable?: IConfigurationTable;

  /**
   * Optional document tracking table
   */
  readonly trackingTable?: ITrackingTable;

  /**
   * The store that manages concurrency limits for document processing.
   * Helps prevent overloading the system with too many concurrent document processing tasks.
   *
   * @default - A new ConcurrencyTable is created
   */
  readonly concurrencyTable?: IConcurrencyTable;

  /**
   * The retention period for document tracking data.
   * Controls how long document metadata and processing results are kept in the system.
   *
   * @default 365 days
   */
  readonly dataTrackingRetention?: cdk.Duration;

  /**
   * The namespace for CloudWatch metrics emitted by the document processing system.
   * Used to organize and identify metrics related to document processing.
   */
  readonly metricNamespace: string;

  /**
   * The retention period for CloudWatch logs generated by the document processing components.
   * Controls how long system logs are kept for troubleshooting and auditing.
   *
   * @default RetentionDays.ONE_WEEK
   */
  readonly logRetention?: logs.RetentionDays;

  /**
   * The log level for the document processing components.
   * Controls the verbosity of logs generated during document processing.
   *
   * @default LogLevel.INFO
   */
  readonly logLevel?: LogLevel;

  /**
   * Optional VPC configuration for document processing components.
   * When provided, deploys processing components within a VPC with specified settings.
   */
  readonly vpcConfiguration?: VpcConfiguration;

  /**
   * Optional reporting environment for analytics and evaluation capabilities.
   * When provided, enables storage and querying of evaluation metrics and processing analytics.
   */
  readonly reportingEnvironment?: IReportingEnvironment;

  /**
   * Optional ProcessingEnvironmentApi for progress notifications.
   * When provided, functions will use GraphQL mutations to update document status
   * and notify clients about processing progress.
   */
  readonly api?: IProcessingEnvironmentApi;

  /**
   * Optional document discovery construct.
   * When provided, enables document discovery functionality including UI uploads.
   */
  readonly documentDiscovery?: IDocumentDiscovery;
}

/**
 * Core infrastructure for the Intelligent Document Processing solution.
 *
 * This construct orchestrates the end-to-end document processing workflow,
 * from document ingestion to structured data extraction and result tracking.
 * It provides the shared infrastructure and services that all document
 * processor patterns use, including:
 *
 * - S3 buckets for document storage
 * - DynamoDB tables for tracking and configuration
 * - SQS queues for document processing
 * - Lambda functions for workflow orchestration
 * - CloudWatch metrics and logs for monitoring
 * - GraphQL API for client interactions
 *
 * The ProcessingEnvironment is designed to be pattern-agnostic, providing
 * the foundation that specific document processor implementations build upon.
 */
export class ProcessingEnvironment
  extends Construct
  implements IProcessingEnvironment
{
  /**
   * Optional KMS key used for encrypting sensitive data in the processing environment.
   * When provided, ensures that document content and metadata are encrypted at rest.
   */
  public readonly encryptionKey?: cdk.aws_kms.IKey;

  /**
   * The namespace for CloudWatch metrics emitted by the document processing system.
   * Used to organize and identify metrics related to document processing.
   */
  public readonly metricNamespace: string;

  /**
   * The S3 bucket where source documents to be processed are stored.
   * This bucket is monitored for new document uploads to trigger processing.
   */
  public readonly inputBucket: IBucket;

  /**
   * The S3 bucket where processed documents and extraction results are stored.
   * Contains the structured data output and processing artifacts.
   */
  public readonly outputBucket: IBucket;

  /**
   * The S3 bucket used for temporary storage during document processing.
   * Contains intermediate processing artifacts and working files.
   */
  public readonly workingBucket: IBucket;

  /**
   * The DynamoDB table that stores configuration settings.
   * Contains document schemas, extraction parameters, and other system-wide settings.
   */
  public readonly configurationTable: IConfigurationTable;

  /**
   * The Lambda function that updates configuration settings.
   * Used to initialize and update configuration during deployment and runtime.
   */
  public readonly configurationFunction: cdk.aws_lambda.IFunction;

  /**
   * The log level for document processing components.
   * Controls the verbosity of logs generated during document processing.
   */
  public readonly logLevel: LogLevel;

  /**
   * The retention period for CloudWatch logs generated by document processing components.
   * Controls how long system logs are kept for troubleshooting and auditing.
   */
  public readonly logRetention?: logs.RetentionDays;

  /**
   * Optional VPC configuration for document processing components.
   * When provided, deploys processing components within a VPC with specified settings.
   */
  public readonly vpcConfiguration?: VpcConfiguration | undefined;

  /**
   * Optional reporting environment for analytics and evaluation capabilities.
   * When provided, enables storage and querying of evaluation metrics and processing analytics.
   */
  public readonly reportingEnvironment?: IReportingEnvironment;

  /**
   * Optional Lambda function that saves reporting data to the reporting bucket.
   * Available when a reporting environment is provided.
   */
  public readonly saveReportingDataFunction?: lambda.IFunction;

  /**
   * Optional ProcessingEnvironmentApi for progress notifications.
   * When provided, functions will use GraphQL mutations to update document status.
   */
  public readonly api?: IProcessingEnvironmentApi;

  /**
   * Optional document discovery system for automated configuration generation.
   * When provided, enables discovery job processing, status tracking, and UI upload functionality.
   */
  public readonly documentDiscovery?: IDocumentDiscovery;

  /**
   * The DynamoDB table that tracks document processing status and metadata.
   * Stores information about documents being processed, including status and results.
   */
  public readonly trackingTable: ITrackingTable;
  /**
   * The DynamoDB table that manages concurrency limits for document processing.
   * Helps prevent overloading the system with too many concurrent document processing tasks.
   */
  private readonly concurrencyTable: IConcurrencyTable;

  /**
   * The KMS key used for encrypting sensitive data in the processing environment.
   * When provided, ensures that document content and metadata are encrypted at rest.
   */
  private readonly key: kms.IKey | undefined;

  /**
   * Lambda function that sends documents to the processing queue.
   * Triggered when new documents are uploaded to the input bucket.
   */
  private readonly queueSender: lambda.IFunction;

  /**
   * SQS queue that holds documents waiting to be processed.
   * Provides buffering and reliable delivery of document processing requests.
   */
  private readonly documentQueue: sqs.IQueue;

  /**
   * Lambda function that tracks workflow execution status.
   * Updates document status in the tracking table based on Step Functions events.
   */
  private readonly workflowTracker: lambda.IFunction;

  /**
   * Lambda function that looks up document information from the tracking table.
   * Used to retrieve document metadata and processing status.
   */
  private readonly lookupFunction: lambda.IFunction;

  constructor(scope: Construct, id: string, props: ProcessingEnvironmentProps) {
    super(scope, id);

    const {
      dataTrackingRetention = cdk.Duration.days(365),
      logLevel = LogLevel.INFO,
      logRetention = logs.RetentionDays.ONE_WEEK,
      concurrencyTable = new ConcurrencyTable(this, "ConcurrencyTable", {
        encryptionKey: this.encryptionKey,
      }),
    } = props;

    this.encryptionKey = props.key;
    this.metricNamespace = props.metricNamespace;
    this.key = this.encryptionKey;
    this.logRetention = logRetention ?? logs.RetentionDays.ONE_WEEK;

    this.inputBucket = props.inputBucket;
    this.outputBucket = props.outputBucket;
    this.workingBucket = props.workingBucket;
    this.logLevel = logLevel;
    this.concurrencyTable = concurrencyTable;
    this.vpcConfiguration = props.vpcConfiguration;

    this.trackingTable =
      props.trackingTable ??
      new TrackingTable(this, "TrackingTable", {
        encryption: props.key
          ? dynamodb.TableEncryption.CUSTOMER_MANAGED
          : undefined,
        encryptionKey: props.key,
      });

    this.configurationTable =
      props.configurationTable ??
      new ConfigurationTable(this, "ConfigurationTable", {
        encryptionKey: props.key,
      });

    // Use provided reporting environment
    this.reportingEnvironment = props.reportingEnvironment;

    // Use provided API for progress notifications
    this.api = props.api;

    // Use provided document discovery
    this.documentDiscovery = props.documentDiscovery;

    this.configurationFunction = new functions.UpdateConfigurationFunction(
      this,
      "UpdateConfigurationFunction",
      {
        key: this.key,
        configurationTable: this.configurationTable,
        ...this.vpcConfiguration,
      },
    );

    // SQS Dead Letter Queue (DLQ)
    const documentQueueDLQ = new sqs.Queue(this, "DocumentQueueDLQ", {
      encryptionMasterKey: this.encryptionKey,
      // TODO: move it to props
      visibilityTimeout: cdk.Duration.seconds(30),
      retentionPeriod: cdk.Duration.days(4),
    });

    // SQS Queue
    this.documentQueue = new sqs.Queue(this, "DocumentQueue", {
      encryptionMasterKey: this.encryptionKey,
      // TODO: move it to props
      visibilityTimeout: cdk.Duration.seconds(30),
      retentionPeriod: cdk.Duration.days(1),
      deadLetterQueue: {
        maxReceiveCount: 1000,
        queue: documentQueueDLQ,
      },
    });

    // SQS Dead Letter Queue (DLQ) for QueueSender
    const queueSenderDLQ = new sqs.Queue(this, "QueueSenderDLQ", {
      encryptionMasterKey: this.encryptionKey,
      visibilityTimeout: cdk.Duration.seconds(30),
      retentionPeriod: cdk.Duration.days(4),
    });

    // QueueSender Lambda Function
    this.queueSender = new functions.QueueSenderFunction(this, "QueueSender", {
      logLevel: this.logLevel,
      documentQueue: this.documentQueue,
      trackingTable: this.trackingTable,
      outputBucket: this.outputBucket,
      dataRetentionInDays: dataTrackingRetention.toDays(),
      deadLetterQueue: queueSenderDLQ,
      api: this.api,
      logGroup: new logs.LogGroup(this, "QueueSenderLogGroup", {
        encryptionKey: this.encryptionKey,
        retention: logRetention,
      }),
      ...this.vpcConfiguration,
    });

    // Create Lambda Function
    this.workflowTracker = new functions.WorkflowTrackerFunction(
      this,
      "WorkflowTracker",
      {
        deadLetterQueue: new sqs.Queue(this, "WorkflowTrackerDLQ", {
          encryptionMasterKey: this.encryptionKey,
          visibilityTimeout: cdk.Duration.seconds(30),
          retentionPeriod: cdk.Duration.days(4),
        }),
        logGroup: new logs.LogGroup(this, "WorkflowTrackerLogGroup", {
          encryptionKey: this.encryptionKey,
          retention: logRetention,
        }),
        concurrencyTable,
        metricNamespace: props.metricNamespace,
        trackintTable: this.trackingTable,
        outputBucket: this.outputBucket,
        workingBucket: this.workingBucket,
        reportingEnvironment: this.reportingEnvironment,
        saveReportingDataFunction: this.saveReportingDataFunction,
        api: this.api,
        ...this.vpcConfiguration,
      },
    );

    this.encryptionKey?.grantEncryptDecrypt(this.workflowTracker);

    this.lookupFunction = new functions.LookupFunction(this, "LookupFunction", {
      trackingTable: this.trackingTable,
      encryptionKey: this.encryptionKey,
      logGroup: new logs.LogGroup(this, "LookupFunctionLogGroup", {
        encryptionKey: this.encryptionKey,
        retention: logRetention,
      }),
      ...this.vpcConfiguration,
    });

    // Create SaveReportingDataFunction if reporting environment is provided
    if (this.reportingEnvironment) {
      this.saveReportingDataFunction = new functions.SaveReportingDataFunction(
        this,
        "SaveReportingDataFunction",
        {
          reportingEnvironment: this.reportingEnvironment,
          outputBucket: this.outputBucket,
          metricNamespace: this.metricNamespace,
          environmentEncryption: this.encryptionKey,
          logGroup: new logs.LogGroup(
            this,
            "SaveReportingDataFunctionLogGroup",
            {
              encryptionKey: this.encryptionKey,
              retention: logRetention,
            },
          ),
          ...this.vpcConfiguration,
        },
      );
    } else {
      this.saveReportingDataFunction = undefined;
    }
  }

  attach(
    processor: IDocumentProcessor,
    options?: DocumentProcessorAttachmentOptions,
  ): void {
    // QueueProcessor Lambda Function
    const queueProcessor = new functions.QueueProcessorFunction(
      processor,
      "QueueProcessor",
      {
        logLevel: this.logLevel,
        stateMachine: processor.stateMachine,
        concurrencyTable: this.concurrencyTable,
        maxConcurrent: processor.maxProcessingConcurrency,
        trackingTable: this.trackingTable,
        workingBucket: this.workingBucket,
        encryptionKey: this.key,
        api: this.api,
        logGroup: new logs.LogGroup(processor, "QueueProcessorLogGroup", {
          encryptionKey: this.key,
          retention: this.logRetention,
        }),
        ...this.vpcConfiguration,
      },
    );

    this.documentQueue.grantConsumeMessages(queueProcessor);

    queueProcessor.addEventSource(
      new lambda_event_sources.SqsEventSource(this.documentQueue, {
        batchSize: 50,
        maxBatchingWindow: cdk.Duration.seconds(1),
        reportBatchItemFailures: true,
      }),
    );

    processor.stateMachine.grantStartExecution(queueProcessor);

    const s3EventRule = new events.Rule(processor, "S3EventRule", {
      eventPattern: {
        source: ["aws.s3"],
        detailType: ["Object Created"],
        detail: {
          bucket: {
            // TODO: add also prefix, but align with the team
            name: [this.inputBucket.bucketName],
          },
          object: options?.prefix && {
            key: [{ prefix: options.prefix }],
          },
        },
      },
    });

    s3EventRule.addTarget(new eventtargets.LambdaFunction(this.queueSender));

    // Create EventBridge Rule
    const rule = new events.Rule(processor, "WorkflowStateChangeRule", {
      eventPattern: {
        source: ["aws.states"],
        detailType: ["Step Functions Execution Status Change"],
        detail: {
          stateMachineArn: [processor.stateMachine.stateMachineArn],
          status: ["FAILED", "TIMED_OUT", "ABORTED", "SUCCEEDED"],
        },
      },
    });

    // Add Lambda as target for the rule
    rule.addTarget(
      new eventtargets.LambdaFunction(this.workflowTracker, {
        maxEventAge: cdk.Duration.hours(2),
        retryAttempts: 3,
      }),
    );

    processor.stateMachine.grantRead(this.lookupFunction);

    if (options?.evaluationBucket && options?.evaluationModel) {
      this.createEvaluationFunction(
        processor,
        options.evaluationModel,
        options.evaluationBucket,
      );
    }
  }

  private createEvaluationFunction(
    processor: IDocumentProcessor,
    evaluationInvokable: IInvokable,
    evaluationBaselineBucket: cdk.aws_s3.IBucket,
  ) {
    if (evaluationBaselineBucket) {
      const evaluationFunction = new functions.EvaluationFunction(
        processor,
        "EvaluationFunction",
        {
          metricNamespace: this.metricNamespace,
          logLevel: this.logLevel,
          outputBucket: this.outputBucket,
          workingBucket: this.workingBucket,
          trackingTable: this.trackingTable,
          configurationTable: this.configurationTable,
          baselineBucket: evaluationBaselineBucket,
          reportingEnvironment: this.reportingEnvironment,
          saveReportingDataFunction: this.saveReportingDataFunction,
          api: this.api,
          deadLetterQueue: new sqs.Queue(this, "EvaluationFunctionDLQ", {
            encryptionMasterKey: this.encryptionKey,
            visibilityTimeout: cdk.Duration.seconds(30),
            retentionPeriod: cdk.Duration.days(4),
          }),
          logGroup: new logs.LogGroup(this, "EvaluationFunctionLogGroup", {
            encryptionKey: this.encryptionKey,
            retention: this.logRetention,
          }),
        },
      );

      // TODO: check if this is even needed.
      this.encryptionKey?.grantEncryptDecrypt(evaluationFunction);
      // INFO: this IInvokable is not passed to the function via env vars, but through configuration in DDB
      evaluationInvokable.grantInvoke(evaluationFunction);

      new events.Rule(this, "EvaluationFunctionRule", {
        eventPattern: {
          source: ["aws.states"],
          detailType: ["Step Functions Execution Status Change"],
          detail: {
            stateMachineArn: [processor.stateMachine.stateMachineArn],
            status: ["SUCCEEDED"],
          },
        },
        targets: [new eventtargets.LambdaFunction(evaluationFunction)],
      });
    }
  }

  /**
   * Creates a CloudWatch metric for queue latency.
   * Measures the time from when a document is queued to when workflow processing starts.
   *
   * @param props - Optional metric configuration properties
   * @returns CloudWatch Metric for queue latency in milliseconds
   */
  public metricQueueLatency(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric {
    return new cloudwatch.Metric({
      namespace: this.metricNamespace,
      metricName: "QueueLatencyMilliseconds",
      unit: cloudwatch.Unit.MILLISECONDS,
      ...props,
    });
  }

  /**
   * Creates a CloudWatch metric for workflow latency.
   * Measures the time from when workflow processing starts to completion.
   *
   * @param props - Optional metric configuration properties
   * @returns CloudWatch Metric for workflow latency in milliseconds
   */
  public metricWorkflowLatency(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric {
    return new cloudwatch.Metric({
      namespace: this.metricNamespace,
      metricName: "WorkflowLatencyMilliseconds",
      unit: cloudwatch.Unit.MILLISECONDS,
      ...props,
    });
  }

  /**
   * Creates a CloudWatch metric for total processing latency.
   * Measures the end-to-end time from document queuing to completion.
   *
   * @param props - Optional metric configuration properties
   * @returns CloudWatch Metric for total latency in milliseconds
   */
  public metricTotalLatency(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric {
    return new cloudwatch.Metric({
      namespace: this.metricNamespace,
      metricName: "TotalLatencyMilliseconds",
      unit: cloudwatch.Unit.MILLISECONDS,
      ...props,
    });
  }
}
